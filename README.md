Navigator
=========

Компонент позволяет автоматизировать или упростить работу с пагинацией, сортировкой и фильтрацией списка элементов.

Работа начинается с инициализации объекта Navigator с передачей в него объектов Request и URL.

`$navi = new Navigator($request, $url);`

Пагинация
---------

Объект Navigator предоставляет набор методов, для получения первой, последней, следующей, предыдущей страниц, а также быстрой генерации объектов URL для них. 

    $navi->getPage(); // получение номера текущей страницы
    $navi->getFirstPage(); // номер первой страницы
    $navi->getLastPage(); // номер последней страницы
    $navi->getNextPage(); // следующая страница от текущей
    $navi->getPrevPage(); // предыдущая страница от текущей
    
По аналогии, для всех методов есть возможность получить готовый объект URL:

    $navi->getPageUrl(42); // URL с номером страницы 42
    $navi->getFirstPageUrl(); // URL с первой страницей
    ...
    
Функционал постраничности требует, чтобы у Navigator было известно общее количество элементов в выборке и указано количество элементов на странице.

    $navi->setOnpage(10); // Указываем количество элементов на странице
    $navi->setTotal(42); // Указываем количество элементов в выборке
    echo $navi->getTotalPages(); // Результат - количество страниц: 5
    
Сортировка
----------

Navigator позволяет задать допустимые варианты сортировки, а также сформировать ссылки на прямую и обратную сортировку. 

    $navi = new Navigator($request, new URL('hello'));
    $navi->addOrderBy('id'); // Именование и в БД, и в URL совпадает
    $navi->addOrderBy('total', 'Количество', 'count(*)'); // В URL будет параметр вида orderby:total, в SQL `count(*)`
    
После добавления можно получить полный список вариантов сортировки, или отдельные пункты, для формирования списков опций или ссылок в интерфейсе. Каждый вариант сортировки - это объект OrderBy:

    $o = $navi->getOrderByOption('total'); // Получили объект
    $o->asUrlParameter(); // Значение для подстановки в URL: total - сортировка по-возрастанию
    $o->asUrlParameter(false); // _total - сортировка по убыванию
    $o->asSQL(); // SQL выражение для сортировки, в данном случае count(*) ASC
    $o->asUrl(); // Объект URL
    
Если в адресе содержится параметр сортировки, например `.../orderby:_total/`, можно получить текущий порядок для сортировки:

    $navi->getOrderBy();
    
Если адрес не содержит выбора для сортировки, метод вернет `false` или способ сортировки по-умолчанию, если он был указан с помощью метода `$navi->setDefaultOrderBy()`.

Выборка элементов, подсчет количества записей
---------------------------------------------

Navigator может сразу обрабатывать данные о сортировке, фильтрах и пагинации, применять их и получать кол-во элементов в выборке, автоматически расчитывать количество страниц и выдавать соответствующие этим настройкам объекты. 

Если не требуется сложная логика фильтрации, можно воспользоваться настройками, или отнаследоваться от класса и переопределить соответствующие методы.

    $navi->setClass('MyItem'); // Указываем, что используем модель MyItem
    $navi->getTotal(); // Получение общего количества элементов в выборке
    $navi->setOnpage(10); // Указываем количество элементов на странице
    $navi->getItems(); // Получаем нужный набор элементов, с учетом сортировки и текущей страницы

Для расширения возможностей можно переопределить, какие функции будут вызываться для подсчета количества и получения элементов (по-умолчанию это будут `MyItem::Count()` и `MyItem::Find()`):

    $navi->setFuncCount('CountSome'); // Для вызова MyItem::CountSome()
    $navi->setFuncFind('FindSome'); // Для вызова MyItem::FindSome()
    
По-умолчанию в эти методы будут передаваться аргументы, в соответствии с сигнатурами базового класса Item. Если требуется вызов методов с другим набором аргументов, то можно переопределить методы `countTotal()` и `getItems()` при наследовании.

Фильтрация
----------

Механизм фильтрации работает с помощью назначения фильтров - объектов Filter. Базово предусмотрено два фильтра - Equal и Between, выполняющие фильтрацию по прямому соответствию и выборке диапазона. При необходимости реализации более сложной логики можно добавлять произвольные фильтры с использованием анонимных функций или создавать свои фильтры наследуясь от класса Filter.

Рассмотрим на примере:

    $navi->addFilterEqual('one', 'is_numeric'); // Валидация может выполняться с помощью callable-выражений
    $navi->addFilterEqual('two', '/^[a-z]+$/'); // Валидация может выполняться регулярными выражениями
    $navi->addFilterBetween('date'); // На свой страх и риск можно обойтись и без валидации
    $navi->addFilter(
      'some', 
      function(Navigator $navi, Filter $filter) {
        if ($val = $navi->getParameter($filter->getColumn())) {
          if ($filter->validate($val)) {
            $navi->addCondition('... some complicated expression ...');
          }
        }
      }, 
      $validator
    ); // Произвольный фильтр
    
После формирования набора правил можно автоматически обрабатывать адреса и получать набор условий Where для SQL запросов.
Если значение проходит валидацию фильтра, далее оно добавляется с помощью метода `addCondition()`, в результате вызова которого формируется массив условий, используемый автоматически в выборке `getItems()`, а также доступный для получения извне с помощью метода `processFilters()`.

Если требуется, можно указать постоянное условие, не зависящее от фильтров, с помощью `addDefaultCondition()`.

Для вышеописанного набора правил, URL и результат будет следующим:

    URL: /hello/one:1/two:three/date_from:01.01.2014/date_to:31.12.2014/
    Результат: array('one' => 1, 'two' => 'three', '`date` >= "01.01.2014"', '`date` <= "31.12.2014"');

**Важно!** Значения для фильтра Between и пользовательских фильтров подставляются напрямую в запрос, требуется валидация или экранирование входящих данных.

Чистый URL
----------

Важным плюсом работы Navigator`а является то, что вся навигация осуществляется по "чистым адресам". Т.е. если навигатор настроен на параметры one и two, а в адресе будут указаны мусорные параметры, то в ссылках пагинатора и сортировки лишних параметров не будет.

    $navi = new Navigator($request, new URL('hello', array('one' => 1, 'two' => 2, test'=>'me'));
    $navi->addFilterEqual('one');
    $navi->addFilterEqual('two');
    $navi->setPage(42);
    echo $navi->getUrlClean()->toString(); // /hello/one:1/two:2/page:42/
